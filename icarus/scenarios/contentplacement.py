"""Content placement strategies.

This module contains function to decide the allocation of content objects to
source nodes.
"""
import random
import collections
import pickle
import numpy as np

from scipy.stats import norm
from fnss.util import random_from_pdf
from icarus.registry import register_content_placement
from icarus.tools import TruncatedZipfDist

__all__ = ['uniform_content_placement', 'content_placement_from_data', 'weighted_content_placement', 'zipf_content_placement', 'normal_content_placement']


def apply_content_placement(placement, topology):
    """Apply a placement to a topology

    Parameters
    ----------
    placement : dict of sets
        Set of contents to be assigned to nodes keyed by node identifier
    topology : Topology
        The topology
    """
    for v, contents in placement.items():
        topology.node[v]['stack'][1]['contents'] = contents

def get_sources(topology):
    return [v for v in topology if topology.node[v]['stack'][0] == 'source']

@register_content_placement('UNIFORM')
def uniform_content_placement(topology, contents, seed=None):
    """Places content objects to source nodes randomly following a uniform
    distribution.

    Parameters
    ----------
    topology : Topology
        The topology object
    contents : iterable
        Iterable of content objects
    source_nodes : list
        List of nodes of the topology which are content sources

    Returns
    -------
    cache_placement : dict
        Dictionary mapping content objects to source nodes

    Notes
    -----
    A deterministic placement of objects (e.g., for reproducing results) can be
    achieved by using a fix seed value
    """
    random.seed(seed)
    source_nodes = get_sources(topology)
    content_placement = collections.defaultdict(set)
    for c in contents:
        content_placement[random.choice(source_nodes)].add(c)
    with open('record_content', 'wb') as fp:
        pickle.dump(content_placement, fp)
    apply_content_placement(content_placement, topology)

@register_content_placement('DATA_TO_CCF')
def content_placement_from_data (topology, contents, seed=None):
    """Places content objects to source nodes according to data 'outfile_content'.

    Parameters
    ----------
    topology : Topology
        The topology object
    contents : iterable
        Iterable of content objects
    source_nodes : list
        List of nodes of the topology which are content sources

    Returns
    -------
    cache_placement : dict
        Dictionary mapping content objects to source nodes

    Notes
    -----
    A deterministic placement of objects (e.g., for reproducing results) can be
    achieved by using a fix seed value
    """

    with open ('record_content', 'rb') as fp:
        content_placement = pickle.load(fp)
    apply_content_placement(content_placement, topology)

@register_content_placement('WEIGHTED')
def weighted_content_placement(topology, contents, source_weights, seed=None):
    """Places content objects to source nodes randomly according to the weight
    of the source node.

    Parameters
    ----------
    topology : Topology
        The topology object
   contents : iterable
        Iterable of content objects
    source_weights : dict
        Dict mapping nodes nodes of the topology which are content sources and
        the weight according to which content placement decision is made.

    Returns
    -------
    cache_placement : dict
        Dictionary mapping content objects to source nodes

    Notes
    -----
    A deterministic placement of objects (e.g., for reproducing results) can be
    achieved by using a fix seed value
    """

    # IF source_weights is list
    if isinstance(source_weights, list):
        n_sources = len(topology.sources())
        source_weights_dic = {}
        for i in range(n_sources):
            source_weights_dic[n_sources+1+i] = source_weights[i]
        source_weight = source_weights_dic
    # END IF
    
    random.seed(seed)
    norm_factor = float(sum(source_weights.values()))
    source_pdf = dict((k, v / norm_factor) for k, v in source_weights.items())
    content_placement = collections.defaultdict(set)
    for c in contents:
        content_placement[random_from_pdf(source_pdf)].add(c)
    with open('record_content', 'wb') as fp:
        pickle.dump(content_placement, fp)
    apply_content_placement(content_placement, topology)

@register_content_placement('ZIPF')
def zipf_content_placement(topology, contents, alpha, is_random=True, seed=None):
    """Places content objects to source nodes randomly according to the weight
    of the source node. The source_weights is generated by zipf distribution

    Parameters
    ----------
    topology : Topology
        The topology object
   contents : iterable
        Iterable of content objects

    Returns
    -------
    cache_placement : dict
        Dictionary mapping content objects to source nodes

    Notes
    -----
    A deterministic placement of objects (e.g., for reproducing results) can be
    achieved by using a fix seed value
    """
    n_sources = len(topology.sources())
    zipf = TruncatedZipfDist(alpha, n_sources, is_random=is_random)._pdf
    source_weights = {}
    for i in range(n_sources):
        source_weights[n_sources+1+i]=zipf[i]

    random.seed(seed)
    norm_factor = float(sum(source_weights.values()))
    source_pdf = dict((k, v / norm_factor) for k, v in source_weights.items())
    content_placement = collections.defaultdict(set)
    for c in contents:
        content_placement[random_from_pdf(source_pdf)].add(c)
    with open('record_content', 'wb') as fp:
        pickle.dump(content_placement, fp)
    apply_content_placement(content_placement, topology)

@register_content_placement('NORMAL')
def normal_content_placement(topology, contents, is_random=True, seed=None):
    """Places content objects to source nodes randomly according to the weight
    of the source node. The source_weights is generated by zipf distribution

    Parameters
    ----------
    topology : Topology
        The topology object
    contents : iterable
        Iterable of content objects

    Returns
    -------
    cache_placement : dict
        Dictionary mapping content objects to source nodes

    Notes
    -----
    A deterministic placement of objects (e.g., for reproducing results) can be
    achieved by using a fix seed value
    """
    source_number = len(topology.sources())
    # # mean=0, std=1, take the range between +-6 std
    pdf = [norm.cdf(-6+12.0/source_number*i)-norm.cdf(-6+12.0/source_number*(i-1)) for i in range(1,source_number+1)]
    # # calibration
    pdf[0] = norm.cdf(-6+12.0/source_number)
    pdf[-1] = 1-norm.cdf(-6+12.0/source_number*(source_number-1))
    if is_random:
        np.random.shuffle(pdf)
    source_weights = {source_number+1+i : pdf[i] for i in range(source_number)}

    random.seed(seed)
    norm_factor = float(sum(source_weights.values()))
    source_pdf = dict((k, v / norm_factor) for k, v in source_weights.items())
    content_placement = collections.defaultdict(set)
    for c in contents:
        content_placement[random_from_pdf(source_pdf)].add(c)
    with open('record_content', 'wb') as fp:
        pickle.dump(content_placement, fp)
    apply_content_placement(content_placement, topology)
